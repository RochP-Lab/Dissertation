use criterion::{black_box, criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion};
use frost_ed25519 as frost;
use rand::rngs::OsRng;
use std::collections::BTreeMap;
use std::time::Duration;

/*
 * Comprehensive FROST End-to-End Benchmark Suite for Zcash Implementation
 * =====================================================================
 * 
 * This benchmark suite provides statistically rigorous performance analysis
 * of the complete FROST protocol including DKG, signing, and verification
 * phases using Criterion.rs methodology.
 * 
 * Academic Rigor Features:
 * - Statistical analysis with confidence intervals
 * - Outlier detection and removal
 * - Multiple measurement iterations for significance
 * - Regression detection against previous runs
 * - Publication-quality HTML reports with charts
 * 
 * Complete Protocol Coverage:
 * 1. **DKG (Distributed Key Generation)**:
 *    - 3-round protocol: commitments, shares, verification
 *    - Participants: 4, 5, 7, 10, 15, 20, 30, 50, 75, 100
 *    - Thresholds: 1/3 (Byzantine fault tolerance) and 2/3 (supermajority)
 *    - Individual round timing analysis:
 *      * Round 1: Commitment generation (frost::keys::dkg::part1)
 *      * Round 2: Secret share distribution (frost::keys::dkg::part2)
 *      * Round 3: Share verification and key computation (frost::keys::dkg::part3)
 *    - Memory usage profiling
 * 
 * 2. **FROST Signing (2-round protocol + aggregation)**:
 *    - Round 1: Nonce commitment generation (frost::round1::commit)
 *    - Round 2: Signature share creation (frost::round2::sign)
 *    - Aggregation: Combine shares into final signature (frost::aggregate)
 *    - Only threshold participants needed (O(t) complexity)
 *    - Individual round performance breakdown
 * 
 * 3. **Signature Verification**:
 *    - Standard Schnorr verification (frost::keys::VerifyingKey::verify)
 *    - O(1) constant time verification
 *    - Group signature indistinguishable from single-party signature
 * 
 * 4. **End-to-End Workflows**:
 *    - Complete DKG + Sign + Verify benchmarks
 *    - Real-world usage simulation
 *    - Total protocol overhead analysis
 * 
 * 5. **DKG vs Trusted Dealer Comparison**:
 *    - Direct performance comparison across all group sizes (3-100 participants)
 *    - DKG: O(n²) distributed key generation with no single point of trust
 *    - Trusted Dealer: O(n) centralized key generation with single point of trust
 *    - Scaling analysis to identify crossover points and trade-offs
 * 
 * Complexity Analysis:
 * - DKG: O(n²) messages, O(n²) computation, O(n) memory per participant
 * - Signing: O(t) messages, O(t) computation, only threshold participants
 * - Verification: O(1) - constant time, anyone can verify with group public key
 * 
 * Output Formats:
 * - Console: Summary statistics and performance metrics
 * - HTML: Interactive charts and detailed analysis (target/criterion/)
 * - CSV: Raw data for external analysis
 * 
 * Usage:
 *   # Run all benchmarks
 *   cargo bench
 *   
 *   # Run only DKG round breakdown benchmarks (Round 1, 2, 3 individual timing)
 *   cargo bench --bench dkg_scaling dkg_rounds
 *   
 *   # Run specific benchmark categories
 *   cargo bench dkg_one_third         # DKG with 33% thresholds
 *   cargo bench dkg_two_thirds        # DKG with 66% thresholds
 *   cargo bench dkg_vs_trusted_dealer # DKG vs Trusted Dealer comparison across all sizes
 *   cargo bench frost_signing         # FROST signing benchmarks
 *   cargo bench frost_verification    # Signature verification
 *   cargo bench frost_end_to_end      # Complete DKG+Sign+Verify workflow
 *   
 *   # Export to CSV for analysis
 *   cargo bench -- --output-format csv --output-dir ./results
 *   
 *   # Generate detailed HTML reports
 *   cargo bench && open target/criterion/index.html
 */

// Participant count configurations for different test scenarios
const PARTICIPANT_COUNTS: &[u16] = &[3, 5, 10, 20, 40, 60, 100];

/// Calculate threshold for 1/3 majority (tolerates up to 1/3 malicious participants)
/// This is the minimum threshold that can tolerate up to f malicious participants
/// where f = floor((n-1)/3), so threshold = f + 1 = floor((n-1)/3) + 1
/// Minimum threshold is 2 for FROST protocol requirements
fn one_third_threshold(n: u16) -> u16 {
    let threshold = ((n - 1) / 3) + 1;
    std::cmp::max(threshold, 2) // Ensure minimum threshold of 2
}

/// Calculate threshold for 2/3 majority (requires 2/3+ honest participants)
/// This threshold requires at least 2/3 of participants to be honest
/// threshold = ceil(2n/3) = floor((2n + 2)/3)
/// Minimum threshold is 2 for FROST protocol requirements
fn two_thirds_threshold(n: u16) -> u16 {
    let threshold = (2 * n + 2) / 3;
    std::cmp::max(threshold, 2) // Ensure minimum threshold of 2
}

// Complete DKG protocol execution - mirrors production implementation
fn execute_dkg_protocol(
    threshold: u16, 
    limit: u16
) -> Result<(BTreeMap<frost::Identifier, frost::keys::KeyPackage>, frost::keys::PublicKeyPackage), Box<dyn std::error::Error>> {
    let mut rng = OsRng;
    
    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 1: Generate commitments and proofs of knowledge
    ////////////////////////////////////////////////////////////////////////////
    let mut round1_secret_packages = BTreeMap::new();
    let mut received_round1_packages = BTreeMap::new();

    // Each participant performs part1 of the DKG protocol
    for participant_index in 1..=limit {
        let participant_identifier: frost::Identifier = participant_index.try_into().expect("should be nonzero");
        
        let (round1_secret_package, round1_package) = frost::keys::dkg::part1(
            participant_identifier,
            limit,
            threshold,
            &mut rng,
        )?;

        // Store the participant's secret package for later use
        round1_secret_packages.insert(participant_identifier, round1_secret_package);

        // Simulate broadcasting the round1_package to all other participants
        for receiver_index in 1..=limit {
            if receiver_index == participant_index {
                continue;
            }
            let receiver_identifier: frost::Identifier = receiver_index.try_into().expect("should be nonzero");
            received_round1_packages
                .entry(receiver_identifier)
                .or_insert_with(BTreeMap::new)
                .insert(participant_identifier, round1_package.clone());
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 2: Distribute secret shares
    ////////////////////////////////////////////////////////////////////////////
    let mut round2_secret_packages = BTreeMap::new();
    let mut received_round2_packages = BTreeMap::new();

    // Each participant performs part2 of the DKG protocol
    for participant_index in 1..=limit {
        let participant_identifier: frost::Identifier = participant_index.try_into().expect("should be nonzero");
        let round1_secret_package = round1_secret_packages
            .remove(&participant_identifier)
            .unwrap();
        let round1_packages = &received_round1_packages[&participant_identifier];

        let (round2_secret_package, round2_packages) =
            frost::keys::dkg::part2(round1_secret_package, round1_packages)?;

        // Store the participant's secret package for later use
        round2_secret_packages.insert(participant_identifier, round2_secret_package);

        // Send the round2_package to each specific participant
        for (receiver_identifier, round2_package) in round2_packages {
            received_round2_packages
                .entry(receiver_identifier)
                .or_insert_with(BTreeMap::new)
                .insert(participant_identifier, round2_package);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 3: Verify shares and compute final keys
    ////////////////////////////////////////////////////////////////////////////
    let mut key_packages = BTreeMap::new();
    let mut pubkey_packages = BTreeMap::new();

    // Each participant performs part3 of the DKG protocol
    for participant_index in 1..=limit {
        let participant_identifier: frost::Identifier = participant_index.try_into().expect("should be nonzero");
        let round2_secret_package = &round2_secret_packages[&participant_identifier];
        let round1_packages = &received_round1_packages[&participant_identifier];
        let round2_packages = &received_round2_packages[&participant_identifier];

        let (key_package, pubkey_package) = frost::keys::dkg::part3(
            round2_secret_package,
            round1_packages,
            round2_packages,
        )?;

        key_packages.insert(participant_identifier, key_package);
        pubkey_packages.insert(participant_identifier, pubkey_package);
    }

    // All participants should have the same public key package
    let pubkey_package = pubkey_packages
        .into_iter()
        .next()
        .unwrap()
        .1;

    Ok((key_packages, pubkey_package))
}

// Benchmark DKG with 1/3 majority thresholds (tolerates up to 1/3 malicious participants)
fn benchmark_dkg_one_third(c: &mut Criterion) {
    let mut group = c.benchmark_group("DKG_1_3_Majority_Threshold");
    
    // Configure for longer-running tests
    group.measurement_time(Duration::from_secs(30)); // Extend measurement time
    group.warm_up_time(Duration::from_secs(5));      // Longer warm-up
    group.sample_size(10);                           // Minimum required samples for Criterion
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adjust timing based on participant count for very large groups
        if n >= 50 {
            group.measurement_time(Duration::from_secs(120)); // 2 minutes for large groups
            group.sample_size(10);                            // Minimum required samples
        } else if n >= 20 {
            group.measurement_time(Duration::from_secs(60));  // 1 minute for medium groups
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit), // Setup data for each iteration
                    |(t, n)| {
                        // This is the measured operation
                        black_box(execute_dkg_protocol(t, n).expect("DKG should succeed"))
                    },
                    BatchSize::SmallInput, // Each iteration gets fresh setup
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark DKG with 2/3 majority thresholds (requires 2/3+ honest participants)  
fn benchmark_dkg_two_thirds(c: &mut Criterion) {
    let mut group = c.benchmark_group("DKG_2_3_Majority_Threshold");
    
    // Configure for longer-running tests
    group.measurement_time(Duration::from_secs(30)); // Extend measurement time
    group.warm_up_time(Duration::from_secs(5));      // Longer warm-up
    group.sample_size(10);                           // Minimum required samples for Criterion
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        // Adjust timing based on participant count for very large groups
        if n >= 50 {
            group.measurement_time(Duration::from_secs(120)); // 2 minutes for large groups
            group.sample_size(10);                            // Minimum required samples
        } else if n >= 20 {
            group.measurement_time(Duration::from_secs(60));  // 1 minute for medium groups
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_dkg_protocol(t, n).expect("DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark individual DKG rounds for complexity analysis
fn benchmark_dkg_rounds(c: &mut Criterion) {
    let mut group = c.benchmark_group("DKG_Round_Breakdown");
    
    group.measurement_time(Duration::from_secs(10)); // Longer measurement time
    group.warm_up_time(Duration::from_secs(3));      // Adequate warm-up
    group.sample_size(15);                           // Ensure we have enough samples (>10)
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adjust timing for larger tests
        if n >= 50 {
            group.measurement_time(Duration::from_secs(30));
            group.sample_size(10); // Minimum required samples
        }
        
        // Round 1 benchmark - commitment generation
        group.bench_with_input(
            BenchmarkId::new("round1", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let rng = OsRng;
                        (threshold, limit, rng)
                    },
                    |(t, n, mut rng)| {
                        let mut round1_packages = BTreeMap::new();
                        for participant_index in 1..=n {
                            let participant_identifier: frost::Identifier = 
                                participant_index.try_into().expect("should be nonzero");
                            
                            let (_, round1_package) = frost::keys::dkg::part1(
                                participant_identifier,
                                n,
                                t,
                                &mut rng,
                            ).expect("Round 1 should succeed");
                            
                            round1_packages.insert(participant_identifier, round1_package);
                        }
                        black_box(round1_packages)
                    },
                    BatchSize::SmallInput,
                );
            },
        );

        // Round 2 benchmark - secret share distribution
        group.bench_with_input(
            BenchmarkId::new("round2", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let mut rng = OsRng;
                        // Setup Round 1 data needed for Round 2
                        let mut round1_secret_packages = BTreeMap::new();
                        let mut round1_packages = BTreeMap::new();
                        
                        for participant_index in 1..=limit {
                            let participant_identifier: frost::Identifier = 
                                participant_index.try_into().expect("should be nonzero");
                            
                            let (round1_secret_package, round1_package) = frost::keys::dkg::part1(
                                participant_identifier,
                                limit,
                                threshold,
                                &mut rng,
                            ).expect("Round 1 should succeed");
                            
                            round1_secret_packages.insert(participant_identifier, round1_secret_package);
                            round1_packages.insert(participant_identifier, round1_package);
                        }
                        
                        (round1_secret_packages, round1_packages)
                    },
                    |(round1_secret_packages, round1_packages)| {
                        let mut round2_secret_packages = BTreeMap::new();
                        let mut received_round2_packages = BTreeMap::new();
                        
                        // Each participant performs part2 of the DKG protocol
                        for participant_identifier in round1_secret_packages.keys() {
                            let round1_secret_package = &round1_secret_packages[participant_identifier];
                            
                            let (round2_secret_package, round2_packages) =
                                frost::keys::dkg::part2(round1_secret_package.clone(), &round1_packages)
                                    .expect("Round 2 should succeed");
                            
                            round2_secret_packages.insert(*participant_identifier, round2_secret_package);
                            
                            // Distribute round2_packages to respective participants
                            for (receiver_identifier, round2_package) in round2_packages {
                                received_round2_packages
                                    .entry(receiver_identifier)
                                    .or_insert_with(BTreeMap::new)
                                    .insert(*participant_identifier, round2_package);
                            }
                        }
                        
                        black_box((round2_secret_packages, received_round2_packages))
                    },
                    BatchSize::SmallInput,
                );
            },
        );

        // Round 3 benchmark - share verification and key computation
        group.bench_with_input(
            BenchmarkId::new("round3", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let mut rng = OsRng;
                        // Setup Round 1 and Round 2 data needed for Round 3
                        let mut round1_secret_packages = BTreeMap::new();
                        let mut round1_packages = BTreeMap::new();
                        
                        // Round 1
                        for participant_index in 1..=limit {
                            let participant_identifier: frost::Identifier = 
                                participant_index.try_into().expect("should be nonzero");
                            
                            let (round1_secret_package, round1_package) = frost::keys::dkg::part1(
                                participant_identifier,
                                limit,
                                threshold,
                                &mut rng,
                            ).expect("Round 1 should succeed");
                            
                            round1_secret_packages.insert(participant_identifier, round1_secret_package);
                            round1_packages.insert(participant_identifier, round1_package);
                        }
                        
                        // Round 2
                        let mut round2_secret_packages = BTreeMap::new();
                        let mut received_round2_packages = BTreeMap::new();
                        
                        for participant_identifier in round1_secret_packages.keys() {
                            let round1_secret_package = &round1_secret_packages[participant_identifier];
                            
                            let (round2_secret_package, round2_packages) =
                                frost::keys::dkg::part2(round1_secret_package.clone(), &round1_packages)
                                    .expect("Round 2 should succeed");
                            
                            round2_secret_packages.insert(*participant_identifier, round2_secret_package);
                            
                            for (receiver_identifier, round2_package) in round2_packages {
                                received_round2_packages
                                    .entry(receiver_identifier)
                                    .or_insert_with(BTreeMap::new)
                                    .insert(*participant_identifier, round2_package);
                            }
                        }
                        
                        (round1_packages, round2_secret_packages, received_round2_packages)
                    },
                    |(round1_packages, round2_secret_packages, received_round2_packages)| {
                        let mut key_packages = BTreeMap::new();
                        
                        // Each participant performs part3 of the DKG protocol
                        for participant_identifier in round2_secret_packages.keys() {
                            let round2_secret_package = &round2_secret_packages[participant_identifier];
                            let round2_packages = &received_round2_packages[participant_identifier];
                            
                            let (key_package, public_key_package) = frost::keys::dkg::part3(
                                round2_secret_package,
                                &round1_packages,
                                round2_packages,
                            ).expect("Round 3 should succeed");
                            
                            key_packages.insert(*participant_identifier, (key_package, public_key_package));
                        }
                        
                        black_box(key_packages)
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Memory usage benchmark for large participant counts
fn benchmark_dkg_memory_scaling(c: &mut Criterion) {
    let mut group = c.benchmark_group("DKG_Memory_Scaling");
    
    group.measurement_time(Duration::from_secs(30));
    group.sample_size(10); // Minimum required samples for Criterion
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adjust timing for larger memory tests
        if n >= 40 {
            group.measurement_time(Duration::from_secs(60));
        }
        
        group.bench_with_input(
            BenchmarkId::new("memory_footprint", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        // Measure total DKG including memory allocation
                        let result = execute_dkg_protocol(t, n).expect("DKG should succeed");
                        
                        // Calculate approximate memory usage
                        let key_packages_size = result.0.len() * std::mem::size_of::<frost::keys::KeyPackage>();
                        let estimated_memory = key_packages_size + 
                                             std::mem::size_of::<frost::keys::PublicKeyPackage>();
                        
                        black_box((result, estimated_memory))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Comparative analysis: DKG vs Trusted Dealer scaling across all group sizes
fn benchmark_dkg_vs_trusted_dealer(c: &mut Criterion) {
    let mut group = c.benchmark_group("DKG_vs_TrustedDealer_Comparison");
    
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(15);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adjust timing for larger tests
        if n >= 50 {
            group.measurement_time(Duration::from_secs(30));
            group.sample_size(10); // Minimum required samples for large tests
        }
        
        // DKG benchmark - distributed key generation
        group.bench_with_input(
            BenchmarkId::new("DKG", format!("n_{}_t_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_dkg_protocol(t, n).expect("DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
        
        // Trusted Dealer benchmark - centralized key generation
        group.bench_with_input(
            BenchmarkId::new("TrustedDealer", format!("n_{}_t_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let rng = OsRng;
                        (threshold, limit, rng)
                    },
                    |(t, n, mut rng)| {
                        let (shares, pubkey_package) = frost::keys::generate_with_dealer(
                            n,
                            t,
                            frost::keys::IdentifierList::Default,
                            &mut rng,
                        ).expect("Trusted dealer should succeed");

                        let mut key_packages = BTreeMap::new();
                        for (identifier, secret_share) in shares {
                            let key_package = frost::keys::KeyPackage::try_from(secret_share)
                                .expect("KeyPackage conversion should succeed");
                            key_packages.insert(identifier, key_package);
                        }
                        
                        black_box((key_packages, pubkey_package))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// FROST SIGNING BENCHMARKS - Complete End-to-End Protocol
///////////////////////////////////////////////////////////////////////////////

// Execute complete FROST signing protocol (2-round + aggregation)
fn execute_frost_signing(
    key_packages: &BTreeMap<frost::Identifier, frost::keys::KeyPackage>,
    pubkey_package: &frost::keys::PublicKeyPackage,
    threshold: u16,
    message: &[u8],
) -> Result<frost::Signature, Box<dyn std::error::Error>> {
    let mut rng = OsRng;
    
    // Select threshold participants for signing (first 't' participants)
    let mut signers: Vec<frost::Identifier> = key_packages.keys().take(threshold as usize).copied().collect();
    signers.sort();

    ////////////////////////////////////////////////////////////////////////////
    // FROST Round 1: Generate nonce commitments
    ////////////////////////////////////////////////////////////////////////////
    let mut nonces = BTreeMap::new();
    let mut commitments = BTreeMap::new();

    // Each signer generates nonce commitments
    for signer_id in &signers {
        let (nonce, commitment) = frost::round1::commit(
            key_packages[signer_id].signing_share(),
            &mut rng,
        );
        nonces.insert(*signer_id, nonce);
        commitments.insert(*signer_id, commitment);
    }

    ////////////////////////////////////////////////////////////////////////////
    // FROST Round 2: Create signing package and generate signature shares
    ////////////////////////////////////////////////////////////////////////////
    
    // Coordinator creates signing package from commitments
    let signing_package = frost::SigningPackage::new(commitments, message);

    // Each signer creates their signature share
    let mut signature_shares = BTreeMap::new();
    for signer_id in &signers {
        let signature_share = frost::round2::sign(
            &signing_package,
            &nonces[signer_id],
            &key_packages[signer_id],
        )?;
        signature_shares.insert(*signer_id, signature_share);
    }

    ////////////////////////////////////////////////////////////////////////////
    // FROST Aggregation: Combine signature shares into final signature
    ////////////////////////////////////////////////////////////////////////////
    let group_signature = frost::aggregate(
        &signing_package,
        &signature_shares,
        pubkey_package,
    )?;

    Ok(group_signature)
}

// Benchmark FROST signing protocol with different thresholds
// Benchmark FROST signing with 1/3 majority thresholds
fn benchmark_frost_signing_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_Signing_33_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(12);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        if n >= 20 {
            group.measurement_time(Duration::from_secs(25));
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Setup: Generate keys via DKG (not measured)
                        let (key_packages, pubkey_package) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let message = b"FROST signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        // Measure only the signing protocol
                        black_box(execute_frost_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("FROST signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark FROST signing with 2/3 majority thresholds
fn benchmark_frost_signing_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_Signing_66_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(12);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        if n >= 20 {
            group.measurement_time(Duration::from_secs(25));
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Setup: Generate keys via DKG (not measured)
                        let (key_packages, pubkey_package) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let message = b"FROST signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        // Measure only the signing protocol
                        black_box(execute_frost_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("FROST signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark individual FROST signing rounds
fn benchmark_frost_signing_rounds(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_Signing_Round_Breakdown");
    
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(15);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adjust timing for larger signing round tests
        if n >= 40 {
            group.measurement_time(Duration::from_secs(20));
            group.sample_size(10);
        }
        
        // Round 1: Nonce commitment generation
        group.bench_with_input(
            BenchmarkId::new("round1_commitments", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Pre-generate keys (not measured)
                        let (key_packages, _) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let signers: Vec<frost::Identifier> = key_packages.keys()
                            .take(threshold as usize).copied().collect();
                        let rng = OsRng;
                        (key_packages, signers, rng)
                    },
                    |(key_packages, signers, mut rng)| {
                        // Measure Round 1: nonce commitment generation
                        let mut commitments = BTreeMap::new();
                        for signer_id in signers {
                            let (_, commitment) = frost::round1::commit(
                                key_packages[&signer_id].signing_share(),
                                &mut rng,
                            );
                            commitments.insert(signer_id, commitment);
                        }
                        black_box(commitments)
                    },
                    BatchSize::SmallInput,
                );
            },
        );

        // Round 2: Signature share generation
        group.bench_with_input(
            BenchmarkId::new("round2_signature_shares", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Pre-generate keys and round 1 data (not measured)
                        let mut rng = OsRng;
                        let (key_packages, _) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let signers: Vec<frost::Identifier> = key_packages.keys()
                            .take(threshold as usize).copied().collect();
                        
                        let mut nonces = BTreeMap::new();
                        let mut commitments = BTreeMap::new();
                        for signer_id in &signers {
                            let (nonce, commitment) = frost::round1::commit(
                                key_packages[signer_id].signing_share(),
                                &mut rng,
                            );
                            nonces.insert(*signer_id, nonce);
                            commitments.insert(*signer_id, commitment);
                        }
                        
                        let message = b"FROST round 2 benchmark";
                        let signing_package = frost::SigningPackage::new(commitments, message);
                        
                        (key_packages, signers, nonces, signing_package)
                    },
                    |(key_packages, signers, nonces, signing_package)| {
                        // Measure Round 2: signature share generation
                        let mut signature_shares = BTreeMap::new();
                        for signer_id in signers {
                            let signature_share = frost::round2::sign(
                                &signing_package,
                                &nonces[&signer_id],
                                &key_packages[&signer_id],
                            ).expect("Signature share generation should succeed");
                            signature_shares.insert(signer_id, signature_share);
                        }
                        black_box(signature_shares)
                    },
                    BatchSize::SmallInput,
                );
            },
        );

        // Aggregation: Combine signature shares
        group.bench_with_input(
            BenchmarkId::new("aggregation", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Pre-generate complete signing data (not measured)
                        let mut rng = OsRng;
                        let (key_packages, pubkey_package) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let signers: Vec<frost::Identifier> = key_packages.keys()
                            .take(threshold as usize).copied().collect();
                        
                        let mut nonces = BTreeMap::new();
                        let mut commitments = BTreeMap::new();
                        for signer_id in &signers {
                            let (nonce, commitment) = frost::round1::commit(
                                key_packages[signer_id].signing_share(),
                                &mut rng,
                            );
                            nonces.insert(*signer_id, nonce);
                            commitments.insert(*signer_id, commitment);
                        }
                        
                        let message = b"FROST aggregation benchmark";
                        let signing_package = frost::SigningPackage::new(commitments, message);
                        
                        let mut signature_shares = BTreeMap::new();
                        for signer_id in &signers {
                            let signature_share = frost::round2::sign(
                                &signing_package,
                                &nonces[signer_id],
                                &key_packages[signer_id],
                            ).expect("Signature share generation should succeed");
                            signature_shares.insert(*signer_id, signature_share);
                        }
                        
                        (signing_package, signature_shares, pubkey_package)
                    },
                    |(signing_package, signature_shares, pubkey_package)| {
                        // Measure aggregation only
                        black_box(frost::aggregate(
                            &signing_package,
                            &signature_shares,
                            &pubkey_package,
                        ).expect("Aggregation should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark FROST signature verification
// Benchmark FROST verification with 1/3 majority thresholds
fn benchmark_frost_verification_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_Verification_33_Threshold");
    
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(50); // More samples for verification since it's fast
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Pre-generate signature (not measured)
                        let (key_packages, pubkey_package) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let message = b"FROST verification benchmark message";
                        let signature = execute_frost_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("FROST signing should succeed");
                        
                        (pubkey_package, signature, message)
                    },
                    |(pubkey_package, signature, message)| {
                        // Measure verification only
                        let verifying_key = pubkey_package.verifying_key();
                        let is_valid = verifying_key.verify(message, &signature).is_ok();
                        black_box(is_valid)
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// Benchmark FROST verification with 2/3 majority thresholds
fn benchmark_frost_verification_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_Verification_66_Threshold");
    
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(50); // More samples for verification since it's fast
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        // Pre-generate signature (not measured)
                        let (key_packages, pubkey_package) = execute_dkg_protocol(threshold, limit)
                            .expect("DKG should succeed");
                        let message = b"FROST verification benchmark message";
                        let signature = execute_frost_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("FROST signing should succeed");
                        
                        (pubkey_package, signature, message)
                    },
                    |(pubkey_package, signature, message)| {
                        // Measure verification only
                        let verifying_key = pubkey_package.verifying_key();
                        let is_valid = verifying_key.verify(message, &signature).is_ok();
                        black_box(is_valid)
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// End-to-end FROST workflow benchmark (DKG + Sign + Verify) - 33% threshold
fn benchmark_frost_end_to_end_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_End_to_End_33_Threshold");
    
    group.measurement_time(Duration::from_secs(20));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        if n >= 15 {
            group.measurement_time(Duration::from_secs(40));
        }
        if n >= 40 {
            group.measurement_time(Duration::from_secs(120)); // Large groups need more time
            group.sample_size(10); // Minimum required by Criterion
        }
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let message = b"End-to-end FROST complete benchmark";
                        (threshold, limit, message)
                    },
                    |(t, n, message)| {
                        // Measure complete workflow: DKG + Signing + Verification
                        
                        // Phase 1: DKG
                        let (key_packages, pubkey_package) = execute_dkg_protocol(t, n)
                            .expect("DKG should succeed");
                        
                        // Phase 2: FROST Signing
                        let signature = execute_frost_signing(&key_packages, &pubkey_package, t, message)
                            .expect("FROST signing should succeed");
                        
                        // Phase 3: Verification
                        let verifying_key = pubkey_package.verifying_key();
                        let is_valid = verifying_key.verify(message, &signature).is_ok();
                        
                        black_box((key_packages.len(), signature, is_valid))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

// End-to-end FROST workflow benchmark (DKG + Sign + Verify) - 66% threshold
fn benchmark_frost_end_to_end_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("FROST_End_to_End_66_Threshold");
    
    group.measurement_time(Duration::from_secs(20));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        if n >= 15 {
            group.measurement_time(Duration::from_secs(40));
        }
        if n >= 40 {
            group.measurement_time(Duration::from_secs(120)); // Large groups need more time
            group.sample_size(10); // Minimum required by Criterion
        }
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let message = b"End-to-end FROST complete benchmark";
                        (threshold, limit, message)
                    },
                    |(t, n, message)| {
                        // Measure complete workflow: DKG + Signing + Verification
                        
                        // Phase 1: DKG
                        let (key_packages, pubkey_package) = execute_dkg_protocol(t, n)
                            .expect("DKG should succeed");
                        
                        // Phase 2: FROST Signing
                        let signature = execute_frost_signing(&key_packages, &pubkey_package, t, message)
                            .expect("FROST signing should succeed");
                        
                        // Phase 3: Verification
                        let verifying_key = pubkey_package.verifying_key();
                        let is_valid = verifying_key.verify(message, &signature).is_ok();
                        
                        black_box((key_packages.len(), signature, is_valid))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

criterion_group!(
    benches,
    benchmark_dkg_one_third,
    benchmark_dkg_two_thirds,
    benchmark_dkg_memory_scaling,
    benchmark_dkg_vs_trusted_dealer,
    benchmark_frost_signing_33,
    benchmark_frost_signing_66,
    benchmark_frost_signing_rounds,
    benchmark_frost_verification_33,
    benchmark_frost_verification_66,
    benchmark_frost_end_to_end_33,
    benchmark_frost_end_to_end_66
);

// Separate criterion group for DKG round breakdown - can be run independently
criterion_group!(
    dkg_rounds,
    benchmark_dkg_rounds
);

criterion_main!(benches, dkg_rounds);
