/*
 * BLS Threshold Signature Benchmarks - Directory 06-BLSTTC_BLS
 * =============================================================
 * 
 * Tests BLS12-381 threshold signatures using production blsttc library.
 * NOW MATCHES DIRECTORY 01 BEHAVIOR: True participant simulation with message passing.
 * 
 * What it tests:
 * - DKG: TRUE distributed key generation using individual participant objects
 * - Signing: Threshold signature generation and combination  
 * - Verification: BLS pairing-based signature verification
 * - End-to-end: Complete DKG → Sign → Verify workflows
 * 
 * Participant approach (matching directory 01):
 * - Each participant maintains individual state (BLSParticipant struct)
 * - Multi-round interactive protocol with message passing
 * - Round 1: Polynomial generation + commitment broadcast
 * - Round 2: Share exchange and verification (P2P)
 * - Finalization: Key material derivation
 * 
 * Participant scaling: 3, 5, 10, 20, 40, 60, 100 nodes
 * Thresholds: 1/3 majority (Byzantine) and 2/3 majority (supermajority)
 * 
 * Commands:
 *   cargo bench                    # Run all benchmarks
 *   cargo bench BLS_DKG           # DKG only
 *   cargo bench BLS_Signing       # Signing only  
 *   cargo bench BLS_Verification  # Verification only
 *   cargo bench BLS_EndToEnd      # Complete workflows
 * 
 * Library: blsttc v8.0.2 → blstrs → blst (production cryptography stack)
 */

use criterion::{black_box, criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion};
use std::collections::BTreeMap;
use std::time::Duration;
use rand::rngs::OsRng;
use blsttc::{
    PublicKeySet, SecretKeySet,
    SecretKeyShare, Signature,
    poly::{BivarPoly, Poly, BivarCommitment},
    Fr, group::ff::Field,
};

// Participant count configurations - IDENTICAL to FROST benchmarks
const PARTICIPANT_COUNTS: &[u16] = &[3, 5, 10, 20, 40, 60, 100];

// BLS participant identifier
type ParticipantId = u16;

/// Calculate threshold for 1/3 majority (Byzantine fault tolerance)
fn one_third_threshold(n: u16) -> u16 {
    let threshold = ((n - 1) / 3) + 1;
    std::cmp::max(threshold, 2)
}

/// Calculate threshold for 2/3 majority (supermajority)
fn two_thirds_threshold(n: u16) -> u16 {
    let threshold = (2 * n + 2) / 3;
    std::cmp::max(threshold, 2)
}

// DKG message types for participant communication
#[derive(Clone, Debug)]
pub struct Round1Broadcast {
    pub sender_id: ParticipantId,
    pub commitment: BivarCommitment,
}

#[derive(Clone, Debug)]
pub struct Round2P2PShare {
    pub sender_id: ParticipantId,
    pub receiver_id: ParticipantId,
    pub row_poly: Poly,
}

// Individual BLS DKG participant - mirrors Kryptology's DkgParticipant
#[derive(Debug)]
pub struct BLSParticipant {
    pub id: ParticipantId,
    pub threshold: u16,
    pub total_participants: u16,
    pub other_participant_ids: Vec<ParticipantId>,
    
    // DKG state
    pub bi_poly: Option<BivarPoly>,
    pub commitment: Option<BivarCommitment>,
    pub received_commitments: BTreeMap<ParticipantId, BivarCommitment>,
    pub received_shares: BTreeMap<ParticipantId, Fr>,
    pub final_secret_share: Option<Fr>,
    pub secret_key_share: Option<SecretKeyShare>,
}

impl BLSParticipant {
    pub fn new(
        id: ParticipantId, 
        threshold: u16, 
        total_participants: u16,
        other_participant_ids: Vec<ParticipantId>
    ) -> Self {
        Self {
            id,
            threshold,
            total_participants,
            other_participant_ids,
            bi_poly: None,
            commitment: None,
            received_commitments: BTreeMap::new(),
            received_shares: BTreeMap::new(),
            final_secret_share: None,
            secret_key_share: None,
        }
    }
    
    // Round 1: Generate bivariate polynomial and commitment
    pub fn round1(&mut self) -> Result<Round1Broadcast, String> {
        let mut rng = OsRng;
        let faulty_num = (self.threshold as usize).saturating_sub(1);
        
        // Each participant generates their own bivariate polynomial
        let bi_poly = BivarPoly::random(faulty_num, &mut rng);
        let commitment = bi_poly.commitment();
        
        self.bi_poly = Some(bi_poly);
        self.commitment = Some(commitment.clone());
        
        Ok(Round1Broadcast {
            sender_id: self.id,
            commitment,
        })
    }
    
    // Process Round 1 broadcasts from other participants
    pub fn process_round1_broadcasts(&mut self, broadcasts: &[Round1Broadcast]) -> Result<(), String> {
        for broadcast in broadcasts {
            if broadcast.sender_id != self.id {
                self.received_commitments.insert(broadcast.sender_id, broadcast.commitment.clone());
            }
        }
        Ok(())
    }
    
    // Round 2: Generate shares for other participants
    pub fn round2(&self) -> Result<Vec<Round2P2PShare>, String> {
        let bi_poly = self.bi_poly.as_ref()
            .ok_or("Must complete Round 1 first")?;
        
        let mut shares = Vec::new();
        
        // Generate share for each other participant
        for &receiver_id in &self.other_participant_ids {
            let row_poly = bi_poly.row(receiver_id as usize);
            shares.push(Round2P2PShare {
                sender_id: self.id,
                receiver_id,
                row_poly,
            });
        }
        
        Ok(shares)
    }
    
    // Process Round 2 shares from other participants
    pub fn process_round2_shares(&mut self, shares: &[Round2P2PShare]) -> Result<(), String> {
        for share in shares {
            if share.receiver_id == self.id && share.sender_id != self.id {
                // Verify the share against the sender's commitment
                let sender_commitment = self.received_commitments.get(&share.sender_id)
                    .ok_or_else(|| format!("No commitment received from participant {}", share.sender_id))?;
                
                let row_commitment = sender_commitment.row(self.id as usize);
                
                if share.row_poly.commitment() != row_commitment {
                    return Err(format!("Share verification failed for sender {}", share.sender_id));
                }
                
                // Store the verified share
                let share_value = share.row_poly.evaluate(0);
                self.received_shares.insert(share.sender_id, share_value);
            }
        }
        Ok(())
    }
    
    // Finalize: Combine all received shares into final secret key share
    pub fn finalize(&mut self, secret_key_set: &SecretKeySet) -> Result<(), String> {
        // Combine all received shares (including our own)
        let mut final_share = Fr::zero();
        
        // Add our own contribution
        if let Some(bi_poly) = &self.bi_poly {
            let own_share = bi_poly.row(self.id as usize).evaluate(0);
            final_share += own_share;
        }
        
        // Add shares from other participants
        for share_value in self.received_shares.values() {
            final_share += share_value;
        }
        
        self.final_secret_share = Some(final_share);
        
        // Get the actual secret key share from the combined secret key set
        self.secret_key_share = Some(secret_key_set.secret_key_share(self.id as usize));
        
        Ok(())
    }
    
    pub fn get_secret_key_share(&self) -> Option<&SecretKeyShare> {
        self.secret_key_share.as_ref()
    }
}

// BLS key packages using blsttc native types
#[derive(Clone)]
struct BLSKeyPackage {
    secret_key_share: SecretKeyShare,
    participant_id: ParticipantId,
}

#[derive(Clone)]
#[allow(dead_code)]
struct BLSPublicKeyPackage {
    public_key_set: PublicKeySet,
    threshold: u16,
}

// Execute TRUE BLS DKG using participant simulation (matching directory 01 behavior)
fn execute_bls_dkg_protocol(
    num_participants: u16,
    threshold: u16,
) -> Result<(BTreeMap<u16, BLSKeyPackage>, BLSPublicKeyPackage), String> {
    ////////////////////////////////////////////////////////////////////////////
    // PARTICIPANT-BASED DKG PROTOCOL (matching Kryptology/FROST approach)
    // Each participant maintains their own state and exchanges messages
    ////////////////////////////////////////////////////////////////////////////
    
    // Create individual participants (matching directory 01's approach)
    let mut participants: BTreeMap<ParticipantId, BLSParticipant> = BTreeMap::new();
    
    // Initialize all participants
    for participant_id in 1..=num_participants {
        let other_ids: Vec<ParticipantId> = (1..=num_participants)
            .filter(|&id| id != participant_id)
            .collect();
        
        let participant = BLSParticipant::new(
            participant_id,
            threshold,
            num_participants,
            other_ids,
        );
        
        participants.insert(participant_id, participant);
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // ROUND 1: Each participant generates polynomial and broadcasts commitment
    ////////////////////////////////////////////////////////////////////////////
    let mut round1_broadcasts = Vec::new();
    
    for participant in participants.values_mut() {
        let broadcast = participant.round1()?;
        round1_broadcasts.push(broadcast);
    }
    
    // All participants process Round 1 broadcasts
    for participant in participants.values_mut() {
        participant.process_round1_broadcasts(&round1_broadcasts)?;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // ROUND 2: Participants generate and exchange shares (P2P)
    ////////////////////////////////////////////////////////////////////////////
    let mut all_round2_shares = Vec::new();
    
    // Each participant generates shares for others
    for participant in participants.values() {
        let participant_shares = participant.round2()?;
        all_round2_shares.extend(participant_shares);
    }
    
    // All participants process their received shares
    for participant in participants.values_mut() {
        participant.process_round2_shares(&all_round2_shares)?;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // FINALIZATION: Combine polynomials and create final key material
    ////////////////////////////////////////////////////////////////////////////
    
    // Construct combined secret key set from all participants' polynomials
    let mut combined_secret_poly = Poly::zero();
    
    for participant in participants.values() {
        if let Some(bi_poly) = &participant.bi_poly {
            combined_secret_poly += bi_poly.row(0); // Row 0 is the master secret polynomial
        }
    }
    
    let secret_key_set = SecretKeySet::from(combined_secret_poly);
    let public_key_set = secret_key_set.public_keys();
    
    // Finalize each participant's secret key share
    for participant in participants.values_mut() {
        participant.finalize(&secret_key_set)?;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // CREATE KEY PACKAGES (matching directory 01's output format)
    ////////////////////////////////////////////////////////////////////////////
    let mut key_packages = BTreeMap::new();
    
    for (participant_id, participant) in &participants {
        if let Some(secret_key_share) = participant.get_secret_key_share() {
            let key_package = BLSKeyPackage {
                secret_key_share: secret_key_share.clone(),
                participant_id: *participant_id,
            };
            key_packages.insert(*participant_id, key_package);
        } else {
            return Err(format!("Participant {} failed to generate secret key share", participant_id));
        }
    }

    let pubkey_package = BLSPublicKeyPackage {
        public_key_set,
        threshold,
    };

    Ok((key_packages, pubkey_package))
}

// Execute BLS threshold signing using blsttc
fn execute_bls_threshold_signing(
    key_packages: &BTreeMap<ParticipantId, BLSKeyPackage>,
    pubkey_package: &BLSPublicKeyPackage,
    threshold: u16,
    message: &[u8],
) -> Result<Signature, Box<dyn std::error::Error>> {
    ////////////////////////////////////////////////////////////////////////////
    // BLS Threshold Signing with blsttc
    ////////////////////////////////////////////////////////////////////////////
    
    // Select threshold participants for signing
    let signers: Vec<&BLSKeyPackage> = key_packages
        .values()
        .take(threshold as usize)
        .collect();

    // Generate signature shares
    let mut signature_shares = BTreeMap::new();
    
    for key_package in signers {
        let signature_share = key_package.secret_key_share.sign(message);
        signature_shares.insert(key_package.participant_id as usize, signature_share);
    }

    // Combine signature shares into final signature
    let signature = pubkey_package
        .public_key_set
        .combine_signatures(&signature_shares)
        .map_err(|e| format!("Failed to combine signatures: {:?}", e))?;

    Ok(signature)
}

// Full BLS signature verification using blsttc
fn verify_bls_signature(
    signature: &Signature,
    message: &[u8],
    public_key_set: &PublicKeySet,
) -> bool {
    public_key_set.public_key().verify(signature, message)
}

///////////////////////////////////////////////////////////////////////////////
// BLS DKG BENCHMARKS using blsttc native implementation
///////////////////////////////////////////////////////////////////////////////

fn benchmark_bls_dkg_one_third(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_DKG_33_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        if n >= 50 {
            group.measurement_time(Duration::from_secs(30));
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_bls_dkg_protocol(t, n).expect("BLS DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

fn benchmark_bls_dkg_two_thirds(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_DKG_66_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        if n >= 50 {
            group.measurement_time(Duration::from_secs(30));
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_bls_dkg_protocol(t, n).expect("BLS DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// BLS THRESHOLD SIGNING BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn benchmark_bls_signing_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Signing_33_Threshold");
    
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, limit)
                            .expect("BLS DKG should succeed");
                        let message = b"BLS threshold signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        black_box(execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("BLS threshold signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

fn benchmark_bls_signing_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Signing_66_Threshold");
    
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, limit)
                            .expect("BLS DKG should succeed");
                        let message = b"BLS threshold signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        black_box(execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("BLS threshold signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// BLS VERIFICATION BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn bench_bls_verification_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Verification_33_Threshold");
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(n, threshold).unwrap();
        let message = b"BLS verification benchmark message";
        let signature = execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message).unwrap();
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(signature, pubkey_package.public_key_set, message),
            |b, (sig, pks, msg)| {
                b.iter(|| {
                    let valid = black_box(verify_bls_signature(sig, *msg, pks));
                    assert!(valid);
                })
            },
        );
    }
    
    group.finish();
}

fn bench_bls_verification_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Verification_66_Threshold");
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(n, threshold).unwrap();
        let message = b"BLS verification benchmark message";
        let signature = execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message).unwrap();
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(signature, pubkey_package.public_key_set, message),
            |b, (sig, pks, msg)| {
                b.iter(|| {
                    let valid = black_box(verify_bls_signature(sig, *msg, pks));
                    assert!(valid);
                })
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// END-TO-END BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn bench_bls_end_to_end_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_EndToEnd_33_Threshold");
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        let message = b"End-to-end BLS benchmark";
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n, message),
            |b, &(threshold, participants_count, msg)| {
                b.iter(|| {
                    // Phase 1: DKG using blsttc native implementation
                    let (key_packages, pubkey_package) = black_box(
                        execute_bls_dkg_protocol(threshold, participants_count)
                    ).unwrap();
                    
                    // Phase 2: BLS Threshold Signing
                    let signature = black_box(execute_bls_threshold_signing(
                        &key_packages,
                        &pubkey_package,
                        threshold,
                        msg,
                    )).unwrap();
                    
                    // Phase 3: Verification
                    let valid = black_box(verify_bls_signature(
                        &signature,
                        msg,
                        &pubkey_package.public_key_set,
                    ));
                    assert!(valid);
                    
                    (key_packages.len(), signature)
                })
            },
        );
    }
    
    group.finish();
}

fn bench_bls_end_to_end_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_EndToEnd_66_Threshold");
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        let message = b"End-to-end BLS benchmark";
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n, message),
            |b, &(threshold, participants_count, msg)| {
                b.iter(|| {
                    // Phase 1: DKG using blsttc native implementation
                    let (key_packages, pubkey_package) = black_box(
                        execute_bls_dkg_protocol(threshold, participants_count)
                    ).unwrap();
                    
                    // Phase 2: BLS Threshold Signing
                    let signature = black_box(execute_bls_threshold_signing(
                        &key_packages,
                        &pubkey_package,
                        threshold,
                        msg,
                    )).unwrap();
                    
                    // Phase 3: Verification
                    let valid = black_box(verify_bls_signature(
                        &signature,
                        msg,
                        &pubkey_package.public_key_set,
                    ));
                    assert!(valid);
                    
                    (key_packages.len(), signature)
                })
            },
        );
    }
    
    group.finish();
}

criterion_group!(
    benches,
    benchmark_bls_dkg_one_third,
    benchmark_bls_dkg_two_thirds,
    benchmark_bls_signing_33,
    benchmark_bls_signing_66,
    bench_bls_verification_33,
    bench_bls_verification_66,
    bench_bls_end_to_end_33,
    bench_bls_end_to_end_66
);

criterion_main!(benches);
