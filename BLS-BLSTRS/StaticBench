/*
 * Professional BLS True DKG Ben// Participant count configurations - Extended for comprehensive benchmarking
const PARTICIPANT_COUNTS: &[u16] = &[3, 5, 10, 60, 100]; // True DKG with larger groupsmark Suite using blstrs
 * =======================================================
 * 
 * This benchmark suite implements true distributed key generation with VSS
 * using low-level `blstrs` primitives for accurate cryptographic performance
 * measurement without network effects.
 * 
 * Features of True DKG:
 * - Distributed key generation with no trusted dealer
 * - 3-round VSS (Verifiable Secret Sharing) protocol
 * - Cryptographic verification of all shares
 * - BLS12-381 pairing-based threshold signatures
 * 
 * Complete Protocol Coverage:
 * 1. **True DKG**: 3-round distributed key generation with VSS
 * 2. **Threshold Signing**: BLS threshold signature generation
 * 3. **Signature Verification**: Full BLS pairing-based verification
 * 4. **End-to-End Workflows**: Complete DKG + Sign + Verify benchmarks
 * 
 * This provides accurate comparison with FROST implementations using
 * the same participant matrices and statistical analysis methodology.
 * Unlike Directory 09's network simulation, this isolates pure cryptographic
 * operations for precise performance measurement.
 */

use criterion::{black_box, criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion};
use rand::rngs::OsRng;
use std::collections::BTreeMap;
use std::time::Duration;
use blstrs::{G1Projective, G2Projective, Scalar, pairing};
use group::Group;
use ff::Field;
use sha2::{Sha256, Digest};

// Participant count configurations - Extended for comprehensive benchmarking
const PARTICIPANT_COUNTS: &[u16] = &[3, 5, 10, 60, 100]; // True DKG with larger groups

// BLS context for hash-to-curve operations - matches academic standards
const BLS_CONTEXT: &[u8] = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_";

// BLS participant identifier
type ParticipantId = u16;

/// Calculate threshold for 1/3 majority (Byzantine fault tolerance)
fn one_third_threshold(n: u16) -> u16 {
    let threshold = ((n - 1) / 3) + 1;
    std::cmp::max(threshold, 2)
}

/// Calculate threshold for 2/3 majority (supermajority)
fn two_thirds_threshold(n: u16) -> u16 {
    let threshold = (2 * n + 2) / 3;
    std::cmp::max(threshold, 2)
}

// BLS key package for individual participants
#[derive(Clone)]
struct BLSKeyPackage {
    secret_share: Scalar,
}

// BLS public key package for the group
#[derive(Clone)]
struct BLSPublicKeyPackage {
    group_public_key: G1Projective,
}

// VSS (Verifiable Secret Sharing) polynomial commitment
#[derive(Clone)]
struct VSSCommitment {
    coefficients: Vec<G1Projective>,
}

// Secret share with proof for VSS
#[derive(Clone)]
struct SecretShare {
    value: Scalar,
    proof: G1Projective,
}

// DKG round packages 
#[derive(Clone)]
struct DKGRound1Package {
    commitment: VSSCommitment,
}

#[derive(Clone)]
struct DKGRound2Package {
    encrypted_share: SecretShare,
}

// BLS signature
#[derive(Clone)]
struct BLSSignature {
    signature: G2Projective,
}

// Hash function for BLS signing - proper hash-to-curve
fn hash_to_g2(message: &[u8]) -> G2Projective {
    let mut hasher = Sha256::new();
    hasher.update(BLS_CONTEXT);
    hasher.update(message);
    let hash = hasher.finalize();
    
    // Create deterministic point on G2 from hash
    let mut scalar_bytes = [0u8; 32];
    scalar_bytes.copy_from_slice(&hash[..32]);
    
    let scalar = Scalar::from_bytes_le(&scalar_bytes).unwrap_or_else(|| Scalar::from(1u64));
    G2Projective::generator() * scalar
}

// Lagrange coefficient computation for threshold reconstruction
fn compute_lagrange_coefficient(participant_id: ParticipantId, signers: &[ParticipantId]) -> Scalar {
    let mut numerator = Scalar::ONE;
    let mut denominator = Scalar::ONE;
    
    let x_i = Scalar::from(participant_id as u64);
    
    for &other_id in signers {
        if other_id != participant_id {
            let x_j = Scalar::from(other_id as u64);
            numerator *= x_j;
            denominator *= x_j - x_i;
        }
    }
    
    numerator * denominator.invert().unwrap()
}

// Execute complete BLS True DKG protocol - single-threaded, no network simulation
fn execute_bls_dkg_protocol(
    threshold: u16,
    limit: u16,
) -> Result<(BTreeMap<ParticipantId, BLSKeyPackage>, BLSPublicKeyPackage), Box<dyn std::error::Error>> {
    let mut rng = OsRng;
    
    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 1: Polynomial generation and commitment
    ////////////////////////////////////////////////////////////////////////////
    
    let mut round1_secrets = BTreeMap::new();
    let mut received_round1_packages = BTreeMap::new();

    // Each participant generates a random polynomial and commits to it
    for participant_id in 1..=limit {
        let mut polynomial: Vec<Scalar> = Vec::with_capacity(threshold as usize);
        for _ in 0..threshold {
            polynomial.push(Scalar::random(&mut rng));
        }
        
        let commitments: Vec<G1Projective> = polynomial
            .iter()
            .map(|coeff| G1Projective::generator() * coeff)
            .collect();
        
        let commitment = VSSCommitment { coefficients: commitments };
        let round1_package = DKGRound1Package {
            commitment: commitment.clone(),
        };
        
        round1_secrets.insert(participant_id, polynomial);
        
        // Distribute to all other participants (no network delay in benchmark)
        for receiver_id in 1..=limit {
            if receiver_id != participant_id {
                received_round1_packages
                    .entry(receiver_id)
                    .or_insert_with(BTreeMap::new)
                    .insert(participant_id, round1_package.clone());
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 2: Secret share distribution with VSS proofs
    ////////////////////////////////////////////////////////////////////////////
    
    let mut received_round2_packages = BTreeMap::new();

    for sender_id in 1..=limit {
        let polynomial = &round1_secrets[&sender_id];
        
        for receiver_id in 1..=limit {
            if receiver_id != sender_id {
                // Evaluate polynomial at receiver's ID
                let x = Scalar::from(receiver_id as u64);
                let mut share_value = polynomial[0];
                let mut x_power = x;
                
                for &coeff in &polynomial[1..] {
                    share_value += coeff * x_power;
                    x_power *= x;
                }
                
                let proof = G1Projective::generator() * share_value;
                let secret_share = SecretShare { value: share_value, proof };
                let round2_package = DKGRound2Package { encrypted_share: secret_share };
                
                received_round2_packages
                    .entry(receiver_id)
                    .or_insert_with(BTreeMap::new)
                    .insert(sender_id, round2_package);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // DKG Round 3: Verification and key derivation
    ////////////////////////////////////////////////////////////////////////////
    
    let mut key_packages = BTreeMap::new();
    let mut verification_vectors = BTreeMap::new();

    for participant_id in 1..=limit {
        let round1_packages = &received_round1_packages[&participant_id];
        let round2_packages = &received_round2_packages[&participant_id];
        
        // Verify each received share using VSS commitments
        for (&sender_id, round2_package) in round2_packages {
            let commitment = &round1_packages[&sender_id].commitment;
            let share = &round2_package.encrypted_share;
            
            let x = Scalar::from(participant_id as u64);
            let mut expected_commitment = commitment.coefficients[0];
            let mut x_power = x;
            
            for &coeff_commitment in &commitment.coefficients[1..] {
                expected_commitment += coeff_commitment * x_power;
                x_power *= x;
            }
            
            if share.proof != expected_commitment {
                return Err("VSS verification failed".into());
            }
        }
        
        // Compute final secret share
        let mut final_secret_share = Scalar::ZERO;
        for round2_package in round2_packages.values() {
            final_secret_share += round2_package.encrypted_share.value;
        }
        
        // Add own share
        if let Some(own_polynomial) = round1_secrets.get(&participant_id) {
            let x = Scalar::from(participant_id as u64);
            let mut own_share = own_polynomial[0];
            let mut x_power = x;
            
            for &coeff in &own_polynomial[1..] {
                own_share += coeff * x_power;
                x_power *= x;
            }
            final_secret_share += own_share;
        }
        
        // Aggregate verification vector
        let mut aggregated_verification_vector = vec![G1Projective::identity(); threshold as usize];
        for round1_package in round1_packages.values() {
            for (i, &commitment) in round1_package.commitment.coefficients.iter().enumerate() {
                aggregated_verification_vector[i] += commitment;
            }
        }
        
        if let Some(own_polynomial) = round1_secrets.get(&participant_id) {
            for (i, &coeff) in own_polynomial.iter().enumerate() {
                aggregated_verification_vector[i] += G1Projective::generator() * coeff;
            }
        }
        
        let key_package = BLSKeyPackage { secret_share: final_secret_share };
        key_packages.insert(participant_id, key_package);
        verification_vectors.insert(participant_id, aggregated_verification_vector);
    }

    let verification_vector = verification_vectors.into_iter().next().unwrap().1;
    let group_public_key = verification_vector[0];
    let pubkey_package = BLSPublicKeyPackage { group_public_key };

    Ok((key_packages, pubkey_package))
}
// Execute BLS threshold signing
fn execute_bls_threshold_signing(
    key_packages: &BTreeMap<ParticipantId, BLSKeyPackage>,
    _pubkey_package: &BLSPublicKeyPackage,
    threshold: u16,
    message: &[u8],
) -> Result<BLSSignature, Box<dyn std::error::Error>> {
    
    // Select threshold participants for signing
    let mut signers: Vec<ParticipantId> = key_packages.keys().take(threshold as usize).copied().collect();
    signers.sort();

    ////////////////////////////////////////////////////////////////////////////
    // BLS Signing: Individual signature share generation
    ////////////////////////////////////////////////////////////////////////////
    
    let h = hash_to_g2(message);
    let mut signature_shares = BTreeMap::new();
    
    for &signer_id in &signers {
        let key_package = &key_packages[&signer_id];
        let lagrange_coeff = compute_lagrange_coefficient(signer_id, &signers);
        let signature_share = h * (lagrange_coeff * key_package.secret_share);
        signature_shares.insert(signer_id, signature_share);
    }

    ////////////////////////////////////////////////////////////////////////////
    // BLS Aggregation: Combine signature shares into final signature
    ////////////////////////////////////////////////////////////////////////////
    
    let final_signature = signature_shares
        .values()
        .fold(G2Projective::identity(), |acc, &share| acc + share);

    Ok(BLSSignature { signature: final_signature })
}

// Full BLS signature verification using pairings
fn verify_bls_signature(signature: &BLSSignature, message: &[u8], public_key: &G1Projective) -> bool {
    let h = hash_to_g2(message);
    
    // BLS verification: e(H(m), PK) == e(Ïƒ, g1)
    let lhs = pairing(&public_key.into(), &h.into());
    let rhs = pairing(&G1Projective::generator().into(), &signature.signature.into());
    
    lhs == rhs
}

///////////////////////////////////////////////////////////////////////////////
// BLS TRUE DKG BENCHMARKS using blstrs with VSS
///////////////////////////////////////////////////////////////////////////////

fn benchmark_bls_dkg_one_third(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_TrueDKG_33_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        // Adaptive timing for larger participant counts
        if n >= 100 {
            group.measurement_time(Duration::from_secs(120));
            group.sample_size(10);
        } else if n >= 50 {
            group.measurement_time(Duration::from_secs(60));
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_bls_dkg_protocol(t, n).expect("BLS True DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

fn benchmark_bls_dkg_two_thirds(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_TrueDKG_66_Threshold");
    
    group.measurement_time(Duration::from_secs(15));
    group.warm_up_time(Duration::from_secs(3));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        // Adaptive timing for larger participant counts
        if n >= 100 {
            group.measurement_time(Duration::from_secs(120));
            group.sample_size(10);
        } else if n >= 50 {
            group.measurement_time(Duration::from_secs(60));
            group.sample_size(10);
        }
        
        group.bench_with_input(
            BenchmarkId::new("participants", n),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || (threshold, limit),
                    |(t, n)| {
                        black_box(execute_bls_dkg_protocol(t, n).expect("BLS True DKG should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// BLS THRESHOLD SIGNING BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn benchmark_bls_signing_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Signing_33_Threshold");
    
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, limit)
                            .expect("BLS True DKG should succeed");
                        let message = b"BLS threshold signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        black_box(execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("BLS threshold signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

fn benchmark_bls_signing_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Signing_66_Threshold");
    
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n),
            |b, &(threshold, limit)| {
                b.iter_batched(
                    || {
                        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, limit)
                            .expect("BLS True DKG should succeed");
                        let message = b"BLS threshold signature benchmark message";
                        (key_packages, pubkey_package, message)
                    },
                    |(key_packages, pubkey_package, message)| {
                        black_box(execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message)
                            .expect("BLS threshold signing should succeed"))
                    },
                    BatchSize::SmallInput,
                );
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// BLS VERIFICATION BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn bench_bls_verification_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Verification_33_Threshold");
    
    // Configure faster timing for pairing-heavy verification
    group.measurement_time(Duration::from_secs(3));
    group.warm_up_time(Duration::from_secs(1));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        
        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, n).unwrap();
        let message = b"BLS verification benchmark message";
        let signature = execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message).unwrap();
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(signature, pubkey_package.group_public_key, message),
            |b, (sig, pk, msg)| {
                b.iter(|| {
                    let valid = black_box(verify_bls_signature(sig, *msg, pk));
                    assert!(valid);
                })
            },
        );
    }
    
    group.finish();
}

fn bench_bls_verification_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_Verification_66_Threshold");
    
    // Configure faster timing for pairing-heavy verification
    group.measurement_time(Duration::from_secs(3));
    group.warm_up_time(Duration::from_secs(1));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        
        let (key_packages, pubkey_package) = execute_bls_dkg_protocol(threshold, n).unwrap();
        let message = b"BLS verification benchmark message";
        let signature = execute_bls_threshold_signing(&key_packages, &pubkey_package, threshold, message).unwrap();
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(signature, pubkey_package.group_public_key, message),
            |b, (sig, pk, msg)| {
                b.iter(|| {
                    let valid = black_box(verify_bls_signature(sig, *msg, pk));
                    assert!(valid);
                })
            },
        );
    }
    
    group.finish();
}

///////////////////////////////////////////////////////////////////////////////
// END-TO-END BENCHMARKS
///////////////////////////////////////////////////////////////////////////////

fn bench_bls_end_to_end_33(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_EndToEnd_33_Threshold");
    
    // Configure timing for complete end-to-end workflows (DKG + Sign + Verify)
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = one_third_threshold(n);
        let message = b"End-to-end BLS benchmark";
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n, message),
            |b, &(threshold, participants_count, msg)| {
                b.iter(|| {
                    // Phase 1: True DKG with VSS using blstrs
                    let (key_packages, pubkey_package) = black_box(
                        execute_bls_dkg_protocol(threshold, participants_count)
                    ).unwrap();
                    
                    // Phase 2: BLS Threshold Signing
                    let signature = black_box(execute_bls_threshold_signing(
                        &key_packages,
                        &pubkey_package,
                        threshold,
                        msg,
                    )).unwrap();
                    
                    // Phase 3: Verification
                    let valid = black_box(verify_bls_signature(
                        &signature,
                        msg,
                        &pubkey_package.group_public_key,
                    ));
                    assert!(valid);
                    
                    (key_packages.len(), signature)
                })
            },
        );
    }
    
    group.finish();
}

fn bench_bls_end_to_end_66(c: &mut Criterion) {
    let mut group = c.benchmark_group("BLS_EndToEnd_66_Threshold");
    
    // Configure timing for complete end-to-end workflows (DKG + Sign + Verify)
    group.measurement_time(Duration::from_secs(10));
    group.warm_up_time(Duration::from_secs(2));
    group.sample_size(10);
    
    for &n in PARTICIPANT_COUNTS {
        let threshold = two_thirds_threshold(n);
        let message = b"End-to-end BLS benchmark";
        
        group.bench_with_input(
            BenchmarkId::new("n_t", format!("{}_{}", n, threshold)),
            &(threshold, n, message),
            |b, &(threshold, participants_count, msg)| {
                b.iter(|| {
                    // Phase 1: True DKG with VSS using blstrs
                    let (key_packages, pubkey_package) = black_box(
                        execute_bls_dkg_protocol(threshold, participants_count)
                    ).unwrap();
                    
                    // Phase 2: BLS Threshold Signing
                    let signature = black_box(execute_bls_threshold_signing(
                        &key_packages,
                        &pubkey_package,
                        threshold,
                        msg,
                    )).unwrap();
                    
                    // Phase 3: Verification
                    let valid = black_box(verify_bls_signature(
                        &signature,
                        msg,
                        &pubkey_package.group_public_key,
                    ));
                    assert!(valid);
                    
                    (key_packages.len(), signature)
                })
            },
        );
    }
    
    group.finish();
}

criterion_group!(
    benches,
    benchmark_bls_dkg_one_third,
    benchmark_bls_dkg_two_thirds,
    benchmark_bls_signing_33,
    benchmark_bls_signing_66,
    bench_bls_verification_33,
    bench_bls_verification_66,
    bench_bls_end_to_end_33,
    bench_bls_end_to_end_66
);

criterion_main!(benches);
